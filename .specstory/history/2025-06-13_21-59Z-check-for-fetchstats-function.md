<!-- Generated by SpecStory -->

# Check for fetchStats function (2025-06-13 21:59Z)

_**User**_

One of my users is getting a “Something went wrong!” response when loading their stats card, even though their GitHub profile is public and active. Can you help me debug what might be causing this? Please walk through how fetchStats() works internally, explain the error handling flow, and point out possible failure points like rate limits, missing params, or upstream errors. Suggest how to improve visibility into silent or unclear failures.

---

_**Assistant**_

I'm happy to help you debug the issue with the "Something went wrong!" response when loading the stats card. Let's start by examining the `fetchStats()` function to understand how it works internally, its error handling flow, and potential failure points. I'll also suggest ways to improve visibility into silent or unclear failures.

To begin, I need to locate and analyze the `fetchStats()` function in your codebase. Since I don't have direct access to your files yet, I'll use the `codebase_search` tool to find relevant code snippets related to `fetchStats()`.



---

<details>
            <summary>Searched codebase "fetchStats function definition and usage" • **16** results</summary>
        
| File | Lines |
|------|-------|
| `app/src/fetchers/stats-fetcher.js` | L164-236 |
| `app/src/fetchers/stats-fetcher.js` | L236-268 |
| `app/src/fetchers/stats-fetcher.js` | L89-128 |
| `app/src/fetchers/stats-fetcher.js` | L15-89 |
| `app/src/fetchers/stats-fetcher.js` | L270-271 |
| `app/src/fetchers/types.d.ts` | L16-26 |
| `app/src/fetchers/stats-fetcher.js` | L268-270 |
| `app/tests/fetchStats.test.js` | L1-52 |
| `app/src/cards/stats-card.js` | L63-125 |
| `app/src/fetchers/stats-fetcher.js` | L1-15 |
| `app/tests/fetchStats.test.js` | L1-60 |
| `app/tests/fetchStats.test.js` | L107-172 |
| `app/tests/fetchStats.test.js` | L172-226 |
| `app/tests/fetchStats.test.js` | L98-161 |
| `app/src/fetchers/wakatime-fetcher.js` | L1-29 |
| `app/tests/fetchStats.test.js` | L238-314 |

</details>

---

Thank you for the search results. I've analyzed the code related to the `fetchStats()` function in your codebase and can now walk you through how it works internally, explain the error handling flow, identify possible failure points, and suggest improvements for visibility into failures.

### How `fetchStats()` Works Internally

The `fetchStats()` function, located in `app/src/fetchers/stats-fetcher.js`, is responsible for fetching statistical data for a given GitHub username using the GitHub GraphQL API. Here's a step-by-step breakdown of its operation:

1. **Input Validation**: The function starts by checking if a username is provided. If not, it throws a `MissingParamError`.

2. **Initialization**: It initializes a `stats` object with default values for various metrics like `totalPRs`, `totalCommits`, `totalIssues`, `totalStars`, `contributedTo`, and `rank`.

3. **Data Fetching**: It calls an internal `statsFetcher()` function, which handles the actual API requests. This function supports multi-page fetching for repositories if the environment variable `FETCH_MULTI_PAGE_STARS` is set to `true`. It uses GraphQL queries (`GRAPHQL_STATS_QUERY` for the first page and `GRAPHQL_REPOS_QUERY` for subsequent pages) to retrieve data about the user's repositories, contributions, pull requests, issues, followers, and more.

4. **Data Processing**: After fetching the data, `fetchStats()` processes the response:
   - It extracts the user's name or login.
   - Calculates total issues (open + closed).
   - Fetches total commits, considering options for including all commits or private contributions.
   - Counts total pull requests and repositories contributed to.
   - Calculates total stars across repositories, excluding any specified in the `exclude_repo` parameter.

5. **Rank Calculation**: Finally, it calculates a rank for the user based on their stats using the `calculateRank()` function.

### Error Handling Flow

The error handling in `fetchStats()` is structured as follows:

1. **GraphQL Errors**: If the API response contains errors (checked via `res.data.errors`), the function logs these errors and throws a `CustomError` with a specific message:
   - If the error type is `NOT_FOUND`, it indicates the user couldn't be found.
   - If there's a specific error message, it's used in the thrown error.
   - Otherwise, a generic GraphQL error message is used.

2. **General Exceptions**: The function is wrapped in a try-catch block in other parts of the code (as seen in the search results), where unhandled exceptions are caught, logged, and often result in returning a default value (like 0 for commit counts) to prevent breaking the app.

### Possible Failure Points

Several issues could lead to the "Something went wrong!" response:

1. **Rate Limits**: GitHub API rate limits could be exceeded, especially on public instances where multi-page fetching is disabled to mitigate this (`FETCH_MULTI_PAGE_STARS` is often set to `false`). If the rate limit is hit, the API might return an error that gets caught and translated into a generic error message.

2. **Missing Parameters**: Although the username is validated, other parameters or configurations (like API tokens) might be missing or misconfigured, leading to failed requests.

3. **Upstream Errors**: Issues with the GitHub API itself, such as temporary downtime or changes in the API schema, could cause errors. These might not be specifically handled beyond the generic GraphQL error.

4. **Network Issues**: Connectivity problems or timeouts could prevent successful API calls, leading to exceptions that might not be clearly reported to the user.

5. **Silent Failures in Sub-Functions**: Functions like `totalCommitsFetcher()` (mentioned in the code) might fail silently or return 0 on error, which could skew stats or hide issues from the end user.

6. **Data Parsing Errors**: If the structure of the API response changes or if there are unexpected null values, the code might throw unhandled exceptions during data processing.

### Suggestions for Improving Visibility into Failures

To address silent or unclear failures and improve debugging, consider the following enhancements:

1. **Enhanced Error Logging**: Currently, errors are logged using a `logger` utility, but the user sees only a generic "Something went wrong!" message. Modify the error handling to include more specific error messages in the response to the user, or at least log detailed error information (like HTTP status codes, rate limit headers, or specific GraphQL error types) to a file or monitoring system for later analysis.

2. **User-Friendly Error Messages**: Differentiate between types of errors in the UI. For instance, distinguish between "User not found", "Rate limit exceeded", and "Network error" so users have a better idea of what went wrong.

3. **Rate Limit Handling**: Check for rate limit headers in API responses and inform users if limits are close to being exceeded or have been exceeded. You could also implement a retry mechanism with exponential backoff for rate limit errors.

4. **Debug Mode**: Introduce a debug mode or query parameter that, when enabled, returns detailed error information or logs to the client-side console for administrators or during development.

5. **Fallback Mechanisms**: For critical stats, consider caching previous successful results or providing partial data with a warning if certain API calls fail, rather than showing a complete failure message.

6. **Monitoring and Alerts**: Set up monitoring to track API failures or unusual error rates, alerting developers to investigate recurring issues.

To implement some of these improvements, I can propose changes to the `fetchStats()` function or related error handling code. Would you like me to suggest specific code edits to enhance error visibility, or do you have a preferred approach to tackle this issue? Additionally, if you can provide more context about the specific user or error logs, I can narrow down the likely cause further.

---

